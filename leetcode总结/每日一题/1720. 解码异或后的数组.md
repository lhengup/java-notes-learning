来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/decode-xored-array未知 整数数组 arr 由 n 个非负整数组成。



经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。

给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。

请解码返回原数组 arr 。可以证明答案存在并且是唯一的。
![image-20210506094905178](D:/Program%20Files/typora/Notebook/source/image-20210506094905178.png)



题解：

```java
class Solution {
    public int[] decode(int[] encoded, int first) {
        int[] res = new int[encoded.length+1];
        res[0] = first;
        for(int i = 1;i < res.length;i++){
            res[i] = encoded[i-1]^res[i-1];
        }
        return res;
    }
}
```





### 位运算常见操作技巧

#### 基本的位操作

- 与（ & ）每一位进行比较，两位都为1，结果为1，否则为0（-4 & 1 = 0）

```java
  1 0 0 1 1 -->(19)[10]  表示10进制中的19
& 1 1 0 0 1 -->(25)[10]
------------------------------
  1 0 0 0 1 -->(17)[10]
```

- 或（ | ）每一位进行比较，两位有一位是1，结果就是1（-4 | 1 = -3）

```java
  1 0 0 1 1 -->(19)[10]
| 1 1 0 0 1 -->(25)[10]
------------------------------
  1 1 0 1 1 -->(27)[10]
```

- 非（ ~ ） 每一位进行比较，按位取反（符号位也要取反）（~ -4 = 3）

```java
~ 1 0 0 1 1 -->(19)[10]
-----------------------------
  0 1 1 0 0 -->(12)[10]
```

- 异或（ ^ ）每一位进行比较，相同为0，不同为1（^ -4 = -3）

```java
  1 0 0 1 1 -->(19)[10]
^ 1 1 0 0 1 -->(25)[10]
-----------------------------
  0 1 0 1 0 -->(10)[10]
```

#### 初阶位操作

- 交换两个数

```java
int x = 1 , y = 2; 
x^=y;  // x = 0011
y^=x;  // y = 0001 -->(1)[10]
x^=y;  // x = 0010 -->(2)[10] 
//x =2, y =1  x变成y y变成x
```

- 加1操作

```java
int x =1;
x =-(~x); // 0001 --> (~x)后得到1110 --> -(~x) 后得到0010 也就是2，实现了+1操作
//x = 2
```

- 减1操作

```java
int x =2;
x =~(-x); // 0010 -->(-x)后得到1110 --> ~(-x) 后得到 0001 也就是1，实现了-1操作
```

- 或（|）操作和空格转英文字符为小写字符

```java
'a'|' '='a'  
// 'a' --> (1100001)[2] 二进制表示 其是(97)[10]
// ' ' --> (0100000)[2] 二进制表示 其是(32)[10]
  1100001 -->(97)[10]
| 0100000 -->(32)[10]
------------------------------
  1100001 -->(97)[10]    还是'a'本身
```

```java
'A'|' '='a'  
// 'A' --> (1000001)[2] 二进制表示 其是(65)[10]
// ' ' --> (0100000)[2] 二进制表示 其是(32)[10]
  1000001 -->(65)[10]
| 0100000 -->(32)[10]
------------------------------
  1100001 -->(97)[10]    'A'-->'a'
```

- 与（&）操作和下划线转英文字符为大写字符

```java
'a'&'_'='A'  
// 'a' --> (1100001)[2] 二进制表示 其是(97)[10]
// '_' --> (1011111)[2] 二进制表示 其是(95)[10]
  1100001 -->(97)[10]
| 1011111 -->(95)[10]
------------------------------
  1000001 -->(65)[10]    'a'-->'A'
```

```java
'A'&'_'='A'  
// 'A' --> (1000001)[2] 二进制表示 其是(65)[10]
// '_' --> (1011111)[2] 二进制表示 其是(95)[10]
  1000001 -->(65)[10]
| 1011111 -->(95)[10]
------------------------------
  1000001 -->(65)[10]    'A'-->'A'
```

- 异或（^）操作与空格实现大小写英文字符互转

```java
'a'^' '='A'  
// 'a' --> (1100001)[2] 二进制表示 其是(97)[10]
// ' ' --> (0100000)[2] 二进制表示 其是(32)[10]
  1100001 -->(97)[10]
^ 0100000 -->(32)[10]
------------------------------
  1000001 -->(65)[10]   'a'-->'A'
```

```java
'A'^' '='a'  
// 'A' --> (1000001)[2] 二进制表示 其是(65)[10]
// ' ' --> (0100000)[2] 二进制表示 其是(32)[10]
  1000001 -->(65)[10]
^ 0100000 -->(32)[10]
------------------------------
  1100001 -->(97)[10]    'A'-->'a'
```

- 两个数是否异号

```java
int x =-1 , y =2;
x ^ y <0 // true 
  1111 -->(-1)[10]
^ 0010 -->( 2)[10]
------------------------------
  1101 -->(-3)[10]  //前面的1111省略掉了
    
int x =1 , y =2;
x ^ y <0 // false 
  0001 -->(1)[10]
^ 0010 -->(2)[10]
------------------------------
  0011 -->(3)[10] 
```

- 判断奇数偶数：只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数

```java
0 == (a & 1) // true的时候是偶数 false时奇数
```

- 交换符号：将正数变成负数，负数变成正数

  >整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数

```java
int reversal(int a) {
  return ~a + 1;
}
```

- 位操作统计二进制中 1 的个数,相当于求「二进制的汉明重量」

```java
统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，同样以 34520 为例，我们计算其 a &= (a-1)的结果：
方法1：
- 第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000
- 第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000
- 第三次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000 我们发现，每计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：
    
count = 0  
while(a){  
  a = a & (a - 1);  
  count++;  
}  
方法2：见下面的「返回i的二进制最低位位1的权值」
count = 0  
while(a){  
  a -= a & (-a);  
  count++;  
}  
方法3：
count = 0  
while(a){  
  count+=a&1;  
  a >>>= 1;//无符号右移 相当于 /2 
}
```

- 返回`i`的二进制最低位位1的权值

```java
i & (-i)
10100最低位的1权值是4 00100[2]
1001010最低位的1权值是2
111最低位的1权值是1
```

